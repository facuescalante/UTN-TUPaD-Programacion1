# -*- coding: utf-8 -*-
"""Pr√°ctico 11: Aplicaci√≥n de la Recursividad.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FfPByvp7Ie62hqXH9CnUCfRjLdrWRq_u

#Pr√°ctico 11: Aplicaci√≥n de la Recursividad

### Juan Facundo Escalante DNI:24927651

1) Crea una funci√≥n recursiva que calcule el factorial de un n√∫mero. Luego, utiliza esa
funci√≥n para calcular y mostrar en pantalla el factorial de todos los n√∫meros enteros
entre 1 y el n√∫mero que indique el usuario.
"""

def factorial_recur(numero):                  # Defino una funci√≥n recursiva para calcular el factorial de un n√∫mero
    if numero == 0:                           # Si el n√∫mero es 0, devuelvo 1 porque ese es el caso base del factorial
        return 1                              # Retorno 1 como resultado del caso base
    else:                                     # Si el n√∫mero no es 0, sigo con la recursi√≥n
        return numero * factorial_recur(numero - 1)  # Multiplico el n√∫mero actual por el factorial del anterior

pedir_numero = int(input("Ingrese un n√∫mero positivo: "))  # Le pido al usuario que ingrese un n√∫mero entero positivo

for i in range(1, pedir_numero + 1):                       # Recorro desde 1 hasta el n√∫mero que ingres√≥ el usuario, inclusive
    print(f"El factorial de {i} es {factorial_recur(i)}")  # Muestro en pantalla el factorial de cada n√∫mero usando la funci√≥n recursiva

"""2) Crea una funci√≥n recursiva que calcule el valor de la serie de Fibonacci en la posici√≥n
indicada. Posteriormente, muestra la serie completa hasta la posici√≥n que el usuario
especifique.
"""

def fibonacci(n):                             # Defino una funci√≥n recursiva para calcular el valor de la serie de Fibonacci en la posici√≥n n
    if n == 0:                                # Si n es 0, devuelvo 0 porque es el primer n√∫mero de la serie
        return 0
    elif n == 1:                              # Si n es 1, devuelvo 1 porque es el segundo n√∫mero de la serie
        return 1
    else:                                     # Si n es mayor que 1, sumo los dos valores anteriores de la serie
        return fibonacci(n - 1) + fibonacci(n - 2)

# Bucle interactivo para pedir posiciones al usuario
while True:                                  # Inicio un bucle infinito para que el usuario pueda ingresar varias posiciones
    entrada = input("Ingrese un numero (o 'q' para terminar): ")  # Le pido al usuario una posici√≥n o que escriba 'q' para salir

    if entrada.lower() == "q":                                 # Si el usuario escribe 'q', cierro el programa
        print("¬°Hasta luego!")                                    # Le doy un mensaje de despedida
        break                                                 # Salgo del bucle

    if not entrada.isdigit():                                 # Verifico que la entrada sea un n√∫mero v√°lido
        print("Por favor, ingrese un n√∫mero v√°lido.")           # Si no lo es, muestro un mensaje de error
        continue                                               # Vuelvo al inicio del bucle para pedir otra entrada

    pedir_numero = int(entrada)                                  # Convierto la entrada en un n√∫mero entero
    print("Serie de Fibonacci:")                                # Muestro un encabezado para la serie

    i = 0                                  # Inicializo el contador en 0
    while i <= pedir_numero:                              # Recorro desde 0 hasta la posici√≥n ingresada
        print(f"F({i}) = {fibonacci(i)}")                 # Muestro el valor de Fibonacci en la posici√≥n i
        i += 1                                           # Incremento el contador para pasar a la siguiente posici√≥n

"""3) Crea una funci√≥n recursiva que calcule la potencia de un n√∫mero base elevado a un
exponente, utilizando la f√≥rmula ùëõùëö = ùëõ ‚àó ùëõ(ùëö‚àí1). Prueba esta funci√≥n en un
algoritmo general.
"""

def potencia_recursiva(base, exponente):                          # Defino una funci√≥n recursiva que calcula la potencia de un n√∫mero
    if exponente == 0:                                            # Si el exponente es 0, devuelvo 1 porque cualquier n√∫mero elevado a 0 es 1
        return 1
    else:                                                         # Si el exponente es mayor que 0, multiplico la base por la potencia de la base con exponente - 1
        return base * potencia_recursiva(base, exponente - 1)

while True:                                                    # Inicio un bucle infinito para que el usuario pueda calcular varias potencias
  entrada_base = input("Ingrese la base ( o q para salir): ")  # Le pido al usuario que ingrese la base o que escriba 'q' para salir
  if entrada_base.lower() == "q":                                # Si el usuario escribe 'q', cierro el programa
    print("¬°Hasta luego!")                                      # Muestro un mensaje de despedida
    break                                                      # Salgo del bucle

  entra_exponente = input("Ingrese el exponente: ")                # Le pido al usuario que ingrese el exponente

  if not entrada_base.isdigit() or not entra_exponente.isdigit():  # Verifico que ambas entradas sean n√∫meros v√°lidos
    print("Por favor, ingrese n√∫meros v√°lidos.")                   # Si no lo son, muestro un mensaje de error
    continue                                                      # Vuelvo al inicio del bucle para pedir otra entrada

  base = int(entrada_base)                                       # Convierto la base a n√∫mero entero
  exponente = int(entra_exponente)                               # Convierto el exponente a n√∫mero entero

  resultado = potencia_recursiva(base, exponente)                 # Llamo a la funci√≥n recursiva para calcular la potencia
  print(f"{base} elevado a {exponente} es {resultado}\n")          # Muestro el resultado con un salto de l√≠nea al final

"""4) Crear una funci√≥n recursiva en Python que reciba un n√∫mero entero positivo en base
decimal y devuelva su representaci√≥n en binario como una cadena de texto.
"""

def decimal_binario(n):                                                  # Defino una funci√≥n recursiva que convierte un n√∫mero decimal a binario
  if n == 0:                                                           # Si el n√∫mero es 0, devuelvo "0" como caso base
    return "0"
  elif n == 1:                                                          # Si el n√∫mero es 1, devuelvo "1" como otro caso base
    return "1"
  else:                                                                # Si el n√∫mero es mayor que 1, sigo dividiendo por 2 y concateno el residuo
    return decimal_binario(n // 2) + str(n % 2)                         # Llamo recursivamente con n//2 y agrego el bit actual

while True:                                                               # Inicio un bucle infinito para que el usuario pueda convertir varios n√∫meros
    entrada = input("Ingrese un n√∫mero entero positivo (o 'q' para salir): ")  # Le pido al usuario un n√∫mero o que escriba 'q' para salir

    if entrada.lower() == "q":                                           # Si el usuario escribe 'q', cierro el programa
        print("¬°Hasta luego!")                                        # Muestro un mensaje de despedida
        break                                                         # Salgo del bucle

    if not entrada.isdigit():                                  # Verifico que la entrada sea un n√∫mero v√°lido
        print("Por favor, ingrese un n√∫mero v√°lido.")           # Si no lo es, muestro un mensaje de error
        continue                                               # Vuelvo al inicio del bucle para pedir otra entrada

    numero = int(entrada)                                     # Convierto la entrada en un n√∫mero entero
    binario = decimal_binario(numero)                            # Llamo a la funci√≥n recursiva para obtener el binario
    print(f"El n√∫mero {numero} en binario es {binario}\n")  # Muestro el resultado con un salto de l√≠nea

"""5) Implement√° una funci√≥n recursiva llamada es_palindromo(palabra) que reciba una
cadena de texto sin espacios ni tildes, y devuelva True si es un pal√≠ndromo o False si no
lo es.

      Requisitos:
      
      La soluci√≥n debe ser recursiva.
      
      No se debe usar [::-1] ni la funci√≥n reversed().
"""

def es_palindromo(palabra):                                        # Defino una funci√≥n recursiva que verifica si una palabra es un pal√≠ndromo
  if len(palabra) <= 1:                                             # Si la palabra tiene 0 o 1 letra, considero que es un pal√≠ndromo
    return True                                                   # Devuelvo True porque ya no hay m√°s letras para comparar
  elif palabra[0] != palabra[-1]:                                 # Si la primera y la √∫ltima letra son distintas, no es pal√≠ndromo
    return False                                                   # Devuelvo False porque no cumple la condici√≥n
  else:                                                           # Si las letras coinciden, sigo comparando el resto de la palabra
    return es_palindromo(palabra[1:-1])                           # Llamo a la funci√≥n recursivamente sin los extremos

while True:                                                     # Inicio un bucle infinito para que el usuario pueda probar varias palabras
    entrada = input("Ingrese una palabra sin espacios ni tildes (o 'q' para salir): ")  # Le pido al usuario una palabra o que escriba 'q' para salir

    if entrada.lower() == "q":                                  # Si el usuario escribe 'q', cierro el programa
        print("¬°Hasta luego!")                                  # Muestro un mensaje de despedida
        break                                                   # Salgo del bucle

    if not entrada.isalpha():                                    # Verifico que la entrada contenga solo letras
        print("Por favor, ingrese solo letras sin espacios ni s√≠mbolos.")  # Si no lo es, muestro un mensaje de error
        continue                                                # Vuelvo al inicio del bucle para pedir otra entrada

    resultado = es_palindromo(entrada.lower())                     # Llamo a la funci√≥n con la palabra en min√∫sculas para evitar errores por may√∫sculas
    if resultado:                                                   # Si la funci√≥n devuelve True
        print(f"'{entrada}' es un pal√≠ndromo.\n")                     # Muestro que la palabra es un pal√≠ndromo
    else:                                                           # Si la funci√≥n devuelve False
        print(f"'{entrada}' no es un pal√≠ndromo.\n")                   # Muestro que la palabra no es un pal√≠ndromo

"""6) Escrib√≠ una funci√≥n recursiva en Python llamada suma_digitos(n) que reciba un
n√∫mero entero positivo y devuelva la suma de todos sus d√≠gitos.

     Restricciones:
         No se puede convertir el n√∫mero a string.
         Us√° operaciones matem√°ticas (%, //) y recursi√≥n.
"""

def suma_digitos(n):                                           # Defino una funci√≥n recursiva que suma los d√≠gitos de un n√∫mero entero positivo
    if n < 10:                                                 # Si el n√∫mero tiene un solo d√≠gito, lo devuelvo directamente
        return n
    else:                                         # Si tiene m√°s de un d√≠gito, separo el √∫ltimo y sumo con el resto
        return (n % 10) + suma_digitos(n // 10)       # Uso % para obtener el √∫ltimo d√≠gito y // para quitarlo

# Bucle interactivo para probar varios n√∫meros
while True:                                                           # Inicio un bucle infinito para que el usuario pueda ingresar varios valores
    entrada = input("Ingrese un n√∫mero entero positivo (o 'q' para salir): ")  # Le pido al usuario un n√∫mero o que escriba 'q' para salir

    if entrada.lower() == "q":                                          # Si el usuario escribe 'q', cierro el programa
        print("¬°Hasta luego!")                                         # Muestro un mensaje de despedida
        break                                                         # Salgo del bucle

    if not entrada.isdigit():                                        #  Verifico que la entrada sea un n√∫mero v√°lido
        print("Por favor, ingrese un n√∫mero v√°lido.")                    # Si no lo es, muestro un mensaje de error
        continue                                                        # Vuelvo al inicio del bucle para pedir otra entrada

    numero = int(entrada)                                                # Convierto la entrada en un n√∫mero entero
    resultado = suma_digitos(numero)                               # Llamo a la funci√≥n recursiva para calcular la suma de los d√≠gitos
    print(f"La suma de los d√≠gitos de {numero} es {resultado}\n")  # Muestro el resultado con un salto de l√≠nea

"""7) Un ni√±o est√° construyendo una pir√°mide con bloques. En el nivel m√°s bajo coloca n
bloques, en el siguiente nivel uno menos (n - 1), y as√≠ sucesivamente hasta llegar al
√∫ltimo nivel con un solo bloque.

      Escrib√≠ una funci√≥n recursiva contar_bloques(n) que reciba el n√∫mero de bloques en el nivel m√°s bajo y devuelva el total de bloques que necesita para construir toda la pir√°mide.

      Ejemplos:

      contar_bloques(1)   ‚Üí 1         (1)

      contar_bloques(2)   ‚Üí 3         (2 + 1)

      contar_bloques(4)   ‚Üí 10        (4 + 3 + 2 + 1)
"""

def contar_bloques(n):                                          # Defino la funci√≥n recursiva que suma los bloques de cada nivel
    if n == 1:                                                  # Caso base: si el nivel tiene 1 bloque, devuelvo 1
        return 1
    else:                                                       # Paso recursivo: sumo los bloques del nivel actual con los del nivel superior
        return n + contar_bloques(n - 1)

# Bucle interactivo para ingresar varios valores
while True:
    entrada = input("Ingrese la cantidad de bloques en el nivel m√°s bajo (o 'q' para salir): ")  # Le pido al usuario un n√∫mero o que escriba 'q' para salir

    if entrada.lower() == "q":                                  # Si el usuario escribe 'q', cierro el programa
        print("¬°Hasta luego!")                                  # Muestro un mensaje de despedida
        break                                                   # Salgo del bucle

    if not entrada.isdigit():                                   # Verifico que la entrada sea un n√∫mero entero positivo
        print("Por favor, ingrese un n√∫mero entero positivo.")  # Si no lo es, muestro un mensaje de error
        continue                                                # Vuelvo al inicio del bucle para pedir otra entrada

    n = int(entrada)                                            # Convierto la entrada en un n√∫mero entero
    total = contar_bloques(n)                                  # Llamo a la funci√≥n recursiva para calcular el total de bloques

    suma = " + ".join(str(i) for i in range(n, 0, -1))          # Construyo la suma como texto para mostrar c√≥mo se calcula
    print(f"contar_bloques({n}) ‚Üí {total}        ({suma})\n")  # Muestro el resultado con el formato del ejemplo

"""8) Escrib√≠ una funci√≥n recursiva llamada contar_digito(numero, digito) que reciba un n√∫mero entero positivo (numero) y un d√≠gito (entre 0 y 9), y devuelva cu√°ntas veces aparece ese d√≠gito dentro del n√∫mero.

      Ejemplos:
      
      contar_digito(12233421, 2)   ‚Üí 3   
      contar_digito(5555, 5)       ‚Üí 4  
"""

def contar_digito(numero, digito):  # Defino una funci√≥n recursiva que cuenta cu√°ntas veces aparece un d√≠gito en un n√∫mero
    if numero == 0:                         #Caso base: si el n√∫mero ya lleg√≥ a 0, no quedan m√°s d√≠gitos por revisar
        return 0
    else:                                                            # Si todav√≠a hay d√≠gitos por revisar
        ultimo = numero % 10                                         # Obtengo el √∫ltimo d√≠gito del n√∫mero
        resto = numero // 10                                         # Elimino el √∫ltimo d√≠gito para seguir con el resto
        if ultimo == digito:                                         # Si el √∫ltimo d√≠gito coincide con el que estoy buscando
            return 1 + contar_digito(resto, digito)                  # Sumo 1 y sigo buscando en el resto
        else:                                                        # Si no coincide
            return contar_digito(resto, digito)                      # No sumo nada y sigo buscando en el resto

# Bucle interactivo para probar distintos valores
while True:
    entrada_numero = input("Ingrese un n√∫mero entero positivo (o 'q' para salir): ")  # Le pido al usuario un n√∫mero o que escriba 'q' para salir
    if entrada_numero.lower() == "q":                                            # Si el usuario escribe 'q', cierro el programa
        print("¬°Hasta luego!")
        break

    entrada_digito = input("Ingrese el d√≠gito que desea contar (0 a 9): ")  # Le pido el d√≠gito que quiere contar

    if not entrada_numero.isdigit() or not entrada_digito.isdigit():  # Verifico que ambas entradas sean v√°lidas
        print("Por favor, ingrese valores num√©ricos v√°lidos.")
        continue

    numero = int(entrada_numero)                                     # Convierto el n√∫mero a entero
    digito = int(entrada_digito)                                     # Convierto el d√≠gito a entero

    if digito < 0 or digito > 9:                                     # Verifico que el d√≠gito est√© entre 0 y 9
        print("El d√≠gito debe estar entre 0 y 9.")
        continue

    resultado = contar_digito(numero, digito)                                     # Llamo a la funci√≥n recursiva
    print(f"El d√≠gito {digito} aparece {resultado} veces en el n√∫mero {numero}.\n")  # Muestro el resultado